#!/usr/bin/perl

use FindBin;
use lib "$FindBin::Bin/../lib/superglue/perl5";

use Data::Dumper;
use ScriptDie;
use Superglue;
use XML::RPC;

my %opt = Superglue::getopt;
my %creds = Superglue::load_kv $opt{creds};
my %d = Superglue::read_delegation $opt{zone};

my $r;
my $api = XML::RPC->new($creds{url});

sub api_get {
	my $method = shift;
	$r = $api->call($method, $creds{apikey}, $opt{zone});
	print STDERR "$method => ", Dumper([$r]) if $opt{debug};
	sdie "$opt{zone} $method: $r->{faultString}"
	    if ref $r eq HASH and $r->{faultString};
	return $r;
}
sub api_set {
	my $method = shift;
	$r = $api->call($method, $creds{apikey}, @_);
	print STDERR "$method => ", Dumper([$r]) if $opt{debug};
	sdie "$opt{zone} $method: $r->{faultString}"
	    if ref $r eq HASH and $r->{faultString};
	sdie "$opt{zone} $method: $r->{errorType}->{name} ($r->{errorType}->{type})"
	    if ref $r eq HASH and $r->{errorType};
	return $r;
}

if ($d{NS}) {
	my @ns = sort @{api_get('domain.info')->{nameservers}};
	my $ns_match = @ns == @{$d{NS}};
	for my $i (0 .. $#ns) {
		debug "$opt{zone} NS $ns[$i]";
		$ns_match = 0 if $ns[$i] ne $d{NS}[$i];
	}
	debug "NS match?", $ns_match ? 'yes' : 'no';
	my (%add,%mod,%del);
	my @glue = @{api_get('domain.host.list')};
	%add = %{$d{glue}};
	for my $ns (@glue) {
		my $name = $ns->{name};
		my $new_ips = delete $add{$name};
		if (not defined $new_ips) {
			$del{$name} = 1;
			next;
		}
		my @old_ip = sort @{$ns->{ips}};
		my @new_ip = @{$new_ips};
		my $match = @old_ip == @new_ip;
		for my $i (0 .. $#old_ip) {
			debug "$name A $old_ip[$i]"    if $old_ip[$i] =~ $Superglue::re_ipv4;
			debug "$name AAAA $old_ip[$i]" if $old_ip[$i] =~ $Superglue::re_ipv6;
			$match = 0 if $match and $old_ip[$i] ne $new_ip[$i];
		}
		$mod{$name} = $new_ips unless $match;
	}
	my $nadd = scalar keys %add;
	my $nmod = scalar keys %mod;
	my $ndel = scalar keys %del;
	debug "glue changes: create $nadd update $nmod delete $ndel";
	if ($ns_match and $nadd == 0 and $nmod == 0 and $ndel == 0) {
		verbose "$opt{zone}: name server delegation matches";
	} else {
		# the domain.nameservers.set method can create glue in bulk
		# using the nameservers_ips option, but it cannot update nor
		# delete it, so we have to handle those cases individually
		for my $ns (sort keys %mod) {
			api_set 'domain.host.update', $ns, $mod{$ns};
			swarn "$opt{zone} update glue $ns @{$mod{$ns}}"
		}
		for my $ns (sort keys %add) {
			api_set 'domain.host.create', $ns, $add{$ns};
			swarn "$opt{zone} create glue $ns @{$add{$ns}}"
		}
		api_set 'domain.nameservers.set', $opt{zone}, $d{NS};
		swarn "$opt{zone} old NS records";
		swarn "$opt{zone} NS $_" for @ns;
		swarn "$opt{zone} new NS records";
		swarn "$opt{zone} NS $_" for @{$d{NS}};
		for my $ns (sort keys %del) {
			# TODO need to ignore errors here because host
			# objects may be required by multiple domains
			api_set 'domain.host.delete', $ns;
			swarn "delete glue $ns"
		}
	}
}
if ($d{DNSKEY}) {
	my (%add,%del);
	for my $key (@{$d{DNSKEY}}) {
		$key =~ m{^(\d+) 3 (\d+) (.*)$}
		    or sdie "$opt{zone}: cannot parse DNSKEY $key";
		my $f = $1;
		my $a = $2;
		my $pk = $3;
		$pk =~ s{ }{}g;
		$add{"$f $a $pk"} = { flags => $1, algorith => $2, public_key => $pk };
	}
	my @key = @{api_get('domain.dnssec.list')};
	debug sprintf "got %d input keys", scalar keys %add;
	debug sprintf "got %d existing keys", scalar @key;
	for my $i (0 .. $#key) {
		$key[$i]{public_key} =~ s{ }{}g;
		my $f = $key[$i]{flags};
		my $a = $key[$i]{algorithm};
		my $pk = $key[$i]{public_key};
		$del{"$f $a $pk"} = $key[$i]
		    unless delete $add{"$f $a $pk"};
		debug "$opt{zone} DNSKEY $key->{flags} 3 $key->{algorithm} $key->{public_key}";
	}
	my $nadd = scalar keys %add;
	my $ndel = scalar keys %del;
	debug "got $nadd keys to add";
	debug "got $ndel unwanted keys";
	my $key_match = $ndel == 0 && $nadd == 0;
	debug "key match?", $key_match ? 'yes' : 'no';
	if ($key_match) {
		verbose "$opt{zone}: secure delegation matches";
	} else {
	}
}

__END__

=head1 NAME

superglue-gandi - synchronize DNS delegation with Gandi

=head1 SYNOPSIS

B<superglue-gandi> [B<--debug>|B<-d>] [B<--verbose>|B<-v>]
    [B<--not-really>|B<-n>] B<--creds>=I<file>|B<-c>I<file> I<domain>

B<superglue-gandi> B<-h>|B<--help>

=head1 DESCRIPTION

