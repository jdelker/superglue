#!/usr/bin/perl

use FindBin;
use lib "$FindBin::Bin/../lib/superglue/perl5";

use Data::Dumper;
use ScriptDie;
use Superglue;
use XML::RPC;

my %opt = Superglue::getopt;
my %creds = Superglue::load_kv $opt{creds};
my %d = Superglue::read_delegation $opt{zone};

sdie "$opt{creds}: missing url in credentials" unless $creds{url};
sdie "$opt{creds}: missing apikey in credentials" unless $creds{apikey};

my $r;
my $api = XML::RPC->new($creds{url});

sub api_get {
	my $method = shift;
	$r = $api->call($method, $creds{apikey}, $opt{zone});
	print STDERR "$method => ", Dumper([$r]) if $opt{debug};
	sdie "$opt{zone} $method: $r->{faultString}"
	    if ref $r eq HASH and $r->{faultString};
	return $r;
}
sub api_set {
	my $method = shift;
	$r = $api->call($method, $creds{apikey}, @_);
	print STDERR "$method => ", Dumper([$r]) if $opt{debug};
	sdie "$opt{zone} $method: $r->{faultString}"
	    if ref $r eq HASH and $r->{faultString};
	sdie "$opt{zone} $method: $r->{errortype}->{name} ($r->{errortype}->{type})"
	    if ref $r eq HASH and $r->{errortype};
	return $r;
}

if ($d{NS}) {
	my @ns = sort @{api_get('domain.info')->{nameservers}};
	my $ns_match = @ns == @{$d{NS}};
	for my $i (0 .. $#ns) {
		debug "$opt{zone} NS $ns[$i]";
		$ns_match = 0 if $ns[$i] ne $d{NS}[$i];
	}
	debug "NS match?", $ns_match ? 'yes' : 'no';
	my (%add,%old,%new,%del);
	my @glue = @{api_get('domain.host.list')};
	%add = %{$d{glue}};
	for my $ns (@glue) {
		my $name = $ns->{name};
		my $new_ips = delete $add{$name};
		if (not defined $new_ips) {
			$del{$name} = 1;
			next;
		}
		my @old_ip = sort @{$ns->{ips}};
		my @new_ip = @{$new_ips};
		my $match = @old_ip == @new_ip;
		for my $i (0 .. $#old_ip) {
			debug "$name A $old_ip[$i]"    if $old_ip[$i] =~ $Superglue::re_ipv4;
			debug "$name AAAA $old_ip[$i]" if $old_ip[$i] =~ $Superglue::re_ipv6;
			$match = 0 if $match and $old_ip[$i] ne $new_ip[$i];
		}
		unless ($match) {
			$old{$name} = \@old_ip;
			$new{$name} = \@new_ip;
		}
	}
	my $nadd = scalar keys %add;
	my $nmod = scalar keys %old; # same as %new
	my $ndel = scalar keys %del;
	debug "glue changes: create $nadd update $nmod delete $ndel";
	if ($ns_match and $nadd == 0 and $nmod == 0 and $ndel == 0) {
		verbose "$opt{zone}: name server delegation matches";
	} else {
		# The domain.nameservers.set method can create glue in bulk
		# using the nameservers_ips option. It fails if you do not
		# supply necessary glue, but you can omit glue that already
		# exists in the registry (e.g. from a domain.host.create
		# call). It also fails if you supply glue which does not
		# match what is already in the registry: in that case you
		# have to call the domain.host.update method. It does not
		# delete glue for nameservers that you omit from the call;
		# you also have to do that separately.
		#
		# The domain.host.update method can return before the
		# update has completed, which can make the subsequent
		# domain.nameservers.set call fail because the IP addresses
		# are inconsistent. To avoid this problem, we first update
		# the nameserver list, creating any new glue that we need.
		# After that we do any glue modifications that are required,
		# so we don't have to wait for the change to complete.
		#
		# For similar we need to ignore errors when deleting
		# glue, because of the delayed completion of the
		# domain.nameservers.set method. (As far as I can tell the
		# API doesn't provide any particularly good way to find out
		# if/when an operation completed.)
		#
		# TODO: It is possible for domain.nameservers.set to appear
		# to succeed but to quietly have no effect. This can happen
		# if the registry requires host objects to exist for any
		# nameservers that are under the registry's TLD. If this zone
		# has nameservers in a sibling zone, then updating this zone
		# will fail until the sibling zone is updated with matching
		# nameservers. Not sure what to do about this...
		my %set;
		$set{$_} = $add{$_} for keys %add;
		$set{$_} = $old{$_} for keys %old;
		api_set 'domain.nameservers.set', $opt{zone},
		    $d{NS}, { nameservers_ips => \%set }
			unless $opt{'not-really'};
		unless ($ns_match) {
			swarn "$opt{zone} old NS records";
			swarn "$opt{zone} NS $_" for @ns;
			swarn "$opt{zone} new NS records";
			swarn "$opt{zone} NS $_" for @{$d{NS}};
		}
		if ($nadd or $nmod or $ndel) {
			swarn "$opt{zone} alter glue";
		}
		for my $ns (sort keys %add) {
			swarn "$ns create @{$add{$ns}}";
		}
		for my $ns (sort keys %new) {
			api_set 'domain.host.update', $ns, $new{$ns}
			    unless $opt{'not-really'};
			swarn "$ns update @{$new{$ns}}"
		}
		for my $ns (sort keys %del) {

			#my @ns = sort @{api_get('domain.info')->{nameservers}};

			api_set 'domain.host.delete', $ns
			    unless $opt{'not-really'};
			swarn "$ns delete"
		}
		swarn "Not really!" if $opt{'not-really'};
	}
}
if ($d{DNSKEY}) {
	my (%add,%del);
	for my $key (@{$d{DNSKEY}}) {
		$key =~ m{^(\d+) 3 (\d+) (.*)$}
		    or sdie "$opt{zone}: cannot parse DNSKEY $key";
		my $f = $1;
		my $a = $2;
		my $pk = $3;
		$pk =~ s{ }{}g;
		$add{"$f $a $pk"} = { flags => $1, algorith => $2, public_key => $pk };
	}
	my @key = @{api_get('domain.dnssec.list')};
	debug sprintf "got %d input keys", scalar keys %add;
	debug sprintf "got %d existing keys", scalar @key;
	for my $i (0 .. $#key) {
		$key[$i]{public_key} =~ s{ }{}g;
		my $f = $key[$i]{flags};
		my $a = $key[$i]{algorithm};
		my $pk = $key[$i]{public_key};
		$del{"$f $a $pk"} = $key[$i]
		    unless delete $add{"$f $a $pk"};
		debug "$opt{zone} DNSKEY $key->{flags} 3 $key->{algorithm} $key->{public_key}";
	}
	my $nadd = scalar keys %add;
	my $ndel = scalar keys %del;
	debug "got $nadd keys to add";
	debug "got $ndel unwanted keys";
	my $key_match = $ndel == 0 && $nadd == 0;
	debug "key match?", $key_match ? 'yes' : 'no';
	if ($key_match) {
		verbose "$opt{zone}: secure delegation matches";
	} else {
	}
}

__END__

=head1 NAME

superglue-gandi - synchronize DNS delegation with Gandi

=head1 SYNOPSIS

B<superglue-gandi> [B<--debug>|B<-d>] [B<--verbose>|B<-v>]
    [B<--not-really>|B<-n>] B<--creds>=I<file>|B<-c>I<file> I<domain>

B<superglue-gandi> B<-h>|B<--help>

=head1 DESCRIPTION

