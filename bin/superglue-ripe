#!/usr/bin/perl

# https://github.com/RIPE-NCC/whois/wiki/WHOIS-REST-API

use warnings;
use strict;

use Data::Compare;
use FindBin;
use HTTP::Date;
use URI::Escape;

use lib "$FindBin::Bin/../lib";

use Superglue qw(:script :restful);

login_check qw(password);
require_glueless;

error "RIPE domains do not have normal contact information"
    if has_contact;

# When the server times out it returns an HTML response which needs
# separate handling wrt the normal JSON responses.

my $ignore_timeout = sub {
	my $r = shift;
	return ("response is not JSON" => $r->content)
	    unless $r->status_line =~ m{502 Proxy Error}
	    and str2time($r->headers->header('date')) + 50
	      < str2time($r->headers->header('client-date'));
	return;
};

# Extracting error messages from the RIPE REST API is rather
# complicated.

json_error sub {
	my $json = shift;
	my @error;
	for my $e (@{ $json->{errormessages}->{errormessage} }) {
		my $text = $e->{text};
		$text =~ s/%[ds]/$_->{value}/ for @{ $e->{args} };
		push @error, $text;
	}
	chomp @error;
	return join "\n", @error;
};

# Common debug logging and superficial checks.

sub ripe_object {
	my $json = shift;
	my @attr = @{ $json->{objects}->{object}
		  ->[0]->{attributes}->{attribute} };
	error "could not find expected zone in RIPE response"
	    unless Compare $attr[0],
	    { name => 'domain', value => zone };
	for my $a (@attr) {
		# strip extraneous bumf
		delete $a->{link};
		delete $a->{'referenced-type'};
		debug join ': ', @$a{qw{name value}};
	}
	return @attr;
}

# As far as I know, the RIPE REST API is the only way to retrieve
# whois objects over TLS, so use it to read the current state.

base_uri 'https://rest.db.ripe.net/ripe/domain/'.zone;

for (my $attempt = 1; ; $attempt++) {

	# Disable the timeout handler when retrying.
	http_error 0;

	my @old = ripe_object GET '?unfiltered';

	for my $a (@old) {
		old_ns $a->{value} if $a->{name} eq 'nserver';
		old_ds $a->{value} if $a->{name} eq 'ds-rdata';
	}

	if (delegation_matches) {
		notice "delegation matches after $attempt tries"
		    if $attempt > 1;
		exit;
	}

	my @new = ();
	for my $a (@old) {
		push @new, $a unless $a->{name} eq 'nserver'
				  or $a->{name} eq 'ds-rdata';
	}
	for my $ns (keys %{new_ns()}) {
		push @new, { name => 'nserver', value => $ns };
	}
	for my $ds (keys %{new_ds()}) {
		push @new, { name => 'ds-rdata', value => $ds };
	}
	my $new = { objects  => { object    => [
		{ attributes => { attribute => \@new } } ] } };
	ripe_object $new;

	# Although the RIPE REST API has a 'dry-run' parameter, the
	# timeout problems mean that it is no use to us. XXX should
	# not_really mode be more verbose by default?

	if (not_really) {
		notice "not really updating";
		exit;
	}

	my $password = uri_escape login()->{password};

	http_error $ignore_timeout;

	my $r = PUT "?password=$password", $new;

	if (defined $r) {
		ripe_object $r;
		notice "delegation updated";
		exit 0;
	} elsif ($attempt > 5) {
		error "giving up after $attempt tries";
		exit 1;
	} else {
		warning "update timed out, retrying";
	}
}
