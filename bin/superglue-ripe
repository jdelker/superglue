#!/usr/bin/perl

use warnings;
use strict;

use FindBin;
use lib "$FindBin::Bin/../lib/superglue/perl5";

use Data::Dumper;
use Deep;
use JSON::PP;
use LWP::UserAgent;
use ScriptDie;
use Superglue;

my %opt = Superglue::getopt;
my $z = $opt{zone};

#my %creds = Superglue::load_kv $opt{creds};
my %d = Superglue::read_delegation $z;

Superglue::glueless_delegation %d;

my $ripe_url = 'https://rest.db.ripe.net/ripe/domain';

my $ua = LWP::UserAgent->new( agent => 'superglue/0.0' );

sub ripe_error {
	my $r = shift;
	my $error = shift;
	my $body = $r->content;
	my $code = $r->code;
	my $message = $r->message;
	my @r = $r->redirects;
	$r[0] = $r if not @r;
	my $url = $r[0]->request->uri;
	swarn "$code $message from $url";
	swarn $error if $error;
	swarn $body if $body;
	exit 1;
}

sub ripe_request {
	my $req = shift;
	my $r = $ua->request($req);
	my $body = $r->content;
	my $code = $r->code;
	my $message = $r->message;
	ripe_error $r, "unexpected non-JSON response"
	    if $r->header('Content-Type') ne 'application/json';
	my $j = decode_json $r->content;
	delete $j->{'terms-and-conditions'};
	return ($r,$j) if $code eq "200";
	my @error;
	for my $e (@{ $j->{errormessages}->{errormessage} }) {
		my $text = $e->{text};
		$text =~ s/%s/$_->{value}/ for @{ $e->{args} };
		push @error, $text;
	}
	$r->content(join '\n', @error) if @error;
	ripe_error $r;
}

sub ripe_get {
	my $domain = shift;
	my $url = "$ripe_url/$domain?unfiltered";
	my $req = HTTP::Request->new( GET => $url,
		[ 'Accept' => 'application/json' ]);
	my ($r,$j) = ripe_request $req;
	my @obj = @{ $j->{objects}->{object}
		  ->[0]->{attributes}->{attribute} };
	return @obj if defined $obj[0]->{value}
	    and $obj[0]->{value} eq $domain;
	ripe_error $r, "could not find expected domain in JSON response";
}

sub ripe_put {
	my $domain = shift;
	my $password = shift;
	my $url = "$ripe_url/$domain?password=$password";
	$url .= "&dry-run=true" if $opt{'not-really'};
	my $obj = { objects    => { object    => [
		  { attributes => { attribute => \@_
		} } ] } };
	my $req = HTTP::Request->new( PUT => $url,
		[ 'Content-Type' => 'application/json',
		  'Accept' => 'application/json' ],
		encode_json $obj);
debug $req->content;
	return ripe_request $req;
}

my @old = ripe_get($opt{zone});

debug Dumper \@old;

my @ns;
my @ds;

for my $a (@old) {
	push @ns, $a->{value} if $a->{name} eq 'nserver';
	push @ds, $a->{value} if $a->{name} eq 'ds-rdata';
}

@ns = sort map lc, @ns;
@ds = sort @ds;

$d{NS} = \@ns unless exists $d{NS};
$d{DS} = \@ds unless exists $d{DS};

my $nseq = deepeq \@ns, $d{NS};
my $dseq = deepeq \@ds, $d{DS};

if ($nseq) {
	verbose "$z NS records match";
} else {
	verbose "$z Old NS records";
	verbose "$z NS $_" for @ns;
	verbose "$z New NS records";
	verbose "$z NS $_" for @{$d{NS}};
}

if ($dseq) {
	verbose "$z DS records match" if $dseq;
} else {
	verbose "$z Old DS records";
	verbose "$z DS $_" for @ds;
	verbose "$z New DS records";
	verbose "$z DS $_" for @{$d{DS}};
}

exit 0 if $nseq and $dseq;

my @new;
for my $a (@old) {
	push @new, $a unless $a->{name} eq 'nserver'
			  or $a->{name} eq 'ds-rdata';
}
for my $ns (@{$d{NS}}) {
	push @new, { name => 'nserver', value => $ns };
}
for my $ds (@{$d{DS}}) {
	push @new, { name => 'ds-rdata', value => $ds };
}
push @new, { name => 'changed', value => 'hostmaster@cam.ac.uk' };

debug Dumper \@new;

ripe_put $z, 'lskjda', @new;

__END__

=head1 NAME

superglue-ripe - synchronize DNS delegation with RIPE

=head1 SYNOPSIS

B<superglue-ripe> [B<--debug>|B<-d>] [B<--verbose>|B<-v>]
    [B<--not-really>|B<-n>] B<--creds>=I<file>|B<-c>I<file> I<domain>

B<superglue-ripei> B<-h>|B<--help>

=head1 DESCRIPTION

