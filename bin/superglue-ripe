#!/usr/bin/perl

# https://github.com/RIPE-NCC/whois/wiki/WHOIS-REST-API

use warnings;
use strict;

use Data::Compare;
use FindBin;
use URI::Escape;

use lib "$FindBin::Bin/../lib";

use Superglue qw(:script :restful);

login_check qw(password);
require_glueless;

error "RIPE domains do not have normal contact information"
    if has_contact;

# Extracting error messages from the RIPE REST API is rather
# complicated.

json_error sub {
	my $json = shift;
	my @error;
	for my $e (@{ $json->{errormessages}->{errormessage} }) {
		my $text = $e->{text};
		$text =~ s/%[ds]/$_->{value}/ for @{ $e->{args} };
		push @error, $text;
	}
	return join "\n", @error;
};

# As far as I know, the RIPE REST API is the only way to retrieve
# whois objects over TLS, so use it to read the current state.

base_uri 'https://rest.db.ripe.net/ripe/domain/'.zone;
my $json = GET '?unfiltered';

my @old = @{ $json->{objects}->{object}
	     ->[0]->{attributes}->{attribute} };

error "could not find expected zone in RIPE response"
    unless Compare $old[0],
    { name => 'domain', value => zone };

for my $a (@old) {
	old_ns $a->{value} if $a->{name} eq 'nserver';
	old_ds $a->{value} if $a->{name} eq 'ds-rdata';
}

exit if delegation_matches;

my @new;
for my $a (@old) {
	push @new, $a unless $a->{name} eq 'nserver'
			  or $a->{name} eq 'ds-rdata';
}
for my $ns (keys %{new_ns()}) {
	push @new, { name => 'nserver', value => $ns };
}
for my $ds (keys %{new_ds()}) {
	push @new, { name => 'ds-rdata', value => $ds };
}
push @new, { name => 'changed', value => 'hostmaster@cam.ac.uk' };

my $new = { objects  => { object    => [
	{ attributes => { attribute => \@new } } ] } };

my $password = uri_escape login()->{password};
my $dry_run = not_really ? '&dry-run=true' : '';

PUT "?password=$password$dry_run", $new;
